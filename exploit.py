#  assume we caught the response for key and ticket request from the client to the auth server:
# and if we know that the header is 23 bytes, followed by 16 bytes of an iv and 32 bytes of an encrypted session key
# we could try to decrypt the session key with a hash of a password from a dictionary, and the iv and get an indication
# if we found the correct password

# after strinpping the header we have:
from common.cryptography_utils import sha256_hash, decrypt_aes_cbc

response_bytes = b'T25!jPL\xbf\xab\x97\x18M\r\xf5\xc60\x177\xb7\x95\xe3$\xec\xf8\xb9\xbd\x9d=\xa2\xe5r\xd9\x01U_\x85\xe9.\xeek\x11\xf5\xde\x95m&\xe1O\x00\xac\xd7\x96\x80A\x91\x8b\xcb\xa2\xd7UU]\xfbpf(\x7f\xf5\xcb\x9e\xe5\xf4\x18)\x1d\xc3Y^}\x16\x9e\xa7\xeb\xd9\xe5\x15\xb7k@\xcbi]UfPz\x18T25!jPL\xbf\xab\x97\x18M\r\xf5\xc60\xa7\xaf\xe2\xdfJ.Ij\xa5\xfe\xbbg\x9bpqV\x00\x00\x00\x00e\xdc\x80\x16\x99K\xeb\x95\xc1r\x96\xd1\x0c\xda\xdd\xb9M\xa8\xf8\x1d.\xe1%\x9c8]\x11&b\x02w\x13\xa1/w\x01\xb2\xa3\xa7F9~\x89p\xa5,!\xa6\x89\xf0\xea\xd0\x04\xcd\xcbU\xb0\xbb\xcc\xf8\xcd\x85\x0e\xc5\xcbI\xfabJ\xd1\x0f\xaf\tM\xcc\xec\x990\x94\xdf\xd2\xe1\xf0\xa9'

# password dictionary
password_list = ['password123', 'mypassword', 'my_password', '12345678', 'qwerty', 'qweasd', 'pass']

iv = response_bytes[0:16]

for password in password_list:
    password_hash = sha256_hash(password.encode('utf-8'))
    try:
        decrypt_aes_cbc(password_hash, response_bytes[16:48], iv)
        print('╔════════════════════════════════════════════════════╗')
        print(f"║ Password found!!! it is {password + ((27 -len(password)) * ' ')}║")
        print("╚════════════════════════════════════════════════════╝")
        exit(0)
    except Exception as e:
        print(f'{password} is not the correct one!')
    print('A password was not found')